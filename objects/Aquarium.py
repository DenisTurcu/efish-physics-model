import time
import numpy as np
import plotly.graph_objects as go
from scipy.spatial.transform import Rotation as R
import contextlib
import os

import sys
sys.path.append('../helper_functions/')

from prefixes import add_prefix, remove_prefix, return_numerical_prefix, parse_prefix
from conversions import rho24sig, convert2mainSI
from ElectricObject import ElectricObject
from Fish import Fish
from Fish_IceCreamCone import IceCreamConeFish
from Worm import Worm
from Boundaries import Plane


class Aquarium(ElectricObject):
    ''' Represents an aquarium for the fish. Can contain multiple fish and worms. Parent class "ElectricObject": '''
    __doc__ += ElectricObject.__doc__


    def __init__(self, fish_objs=[],
                       worm_objs=[],
                       boundaries=[], #[('plane', dict(normal=[0,0,1],central_point=[0,0,0]))], 
                       _init_tests=True, **kwds):
        # initialize parent class properties
        super().__init__(**kwds,_init_tests=False)

        # initialize aquarium boundaries
        self.initialize_boundaries(boundaries)
        self._initialize_input_argument_names()

        # initialize objects in aquarium by emptying it
        self.empty_aquarium()

        # insert provided objects
        for fish in fish_objs:
            self.insert_fish(fish)
        for worm in worm_objs:
            self.insert_worm(worm)

        # Run assertion tests
        if _init_tests:
            print(self.run_tests())


    def initialize_boundaries(self, boundaries):
        ''' Initialize this aquarium's boundaries. '''
        self.boundaries = []
        for boundary in boundaries:
            if boundary[0].lower() == 'plane':
                self.boundaries.append(Plane(normal=boundary[1]['normal'], 
                                             central_point=boundary[1]['central_point']))
            else:
                raise NotImplementedError(f'Boundary type "{boundary[0].lower()}" note yet implemented')
        return


    def _insert_object(self, obj_list, obj, obj_instance, image_currents=False):
        ''' Insert the given object in the aquarium. If the object is a fish, insert its associated image currents as well. '''        
        if obj is not None:
            assert isinstance(obj, obj_instance), f'Given object must be a {obj_instance}.'
            # avoid duplicate objects
            if not image_currents:
                for o in obj_list:
                    if obj.is_equal(o):
                        return obj_list
            obj_list.append(obj)
            if isinstance(obj, Fish):
                self.update_image_currents(obj, mode='insert')
        return obj_list


    def _remove_object(self, obj_list, obj, obj_instance, image_currents=False):
        ''' Remove given object from the aquarium. If the object is a fish, remove its associated image currents as well. '''
        assert isinstance(obj, obj_instance), f'Given object must be a {obj_instance}.'
        temp_obj_list = []
        for o in obj_list:
            if image_currents:
                if not obj.is_equal(o[0]):
                    temp_obj_list.append(o)
            else:
                if not obj.is_equal(o):
                    temp_obj_list.append(o)
                else:
                    if isinstance(obj, Fish):
                        self.update_image_currents(obj, mode='remove')
        if len(temp_obj_list) == len(obj_list):
            print('Object was not found in the aquarium.')
        return temp_obj_list


    def empty_aquarium(self):
        ''' Empty the aquarium of all fish and worms. '''
        self.remove_all_fish()
        self.remove_all_worms()
        return


    def remove_all_fish(self):
        ''' Remove all fish from aquarium, as well as their image currents. '''
        self.fish_objs = []
        self.image_point_currents_magnitude = []
        self.image_point_currents_location  = []
        self.time_stamps = []
        return


    def remove_all_worms(self):
        ''' Remove all worms from aquarium. '''
        self.worm_objs = []
        return


    def update_image_currents(self, obj, mode='insert'):
        ''' Update the image currents generated by the boundaries. Needs to be implemented according to boundary type for each aquarium. '''
        if mode.lower() == 'insert':
            self.image_point_currents_magnitude = self._insert_object(self.image_point_currents_magnitude, (obj, np.array([])                ), tuple, image_currents=True)
            self.image_point_currents_location  = self._insert_object(self.image_point_currents_location,  (obj, np.array([]).reshape([0,3]) ), tuple, image_currents=True)
        elif mode.lower() == 'remove':
            self.image_point_currents_magnitude = self._remove_object(self.image_point_currents_magnitude, obj, Fish, image_currents=True)
            self.image_point_currents_location  = self._remove_object(self.image_point_currents_location,  obj, Fish, image_currents=True)
        return


    def insert_fish(self, obj, _check_points=True):
        ''' Insert a fish in the aquarium. '''
        if obj is not None:
            assert isinstance(obj, Fish), 'Given object must be a fish'
            if _check_points:
                assert self.verify_points(obj.get_receptors_locations(), obj=obj), 'Given fish must lie within aquarium boundaries.'
            for fish in self.fish_objs:
                assert (obj.sampling_rate - fish.sampling_rate) < self.assert_err, 'All fish in the Aquarium must be adjusted to have the same sampling rates of the eod.'
            self.fish_objs =  self._insert_object(self.fish_objs, obj, Fish)
            self.update_time_stamps()


    def insert_worm(self, obj, _check_points=True):
        ''' Insert a worm in the aquarium. '''
        if obj is not None:
            assert isinstance(obj, Worm), 'Given object must be a worm'
            if _check_points:
                assert self.verify_points(obj.get_points(), obj=obj), 'Given worm must lie within aquarium boundaries.'
            self.worm_objs =  self._insert_object(self.worm_objs, obj, Worm)


    def remove_fish(self, obj):
        ''' Remove a fish from the aquarium. '''
        self.fish_objs =  self._remove_object(self.fish_objs, obj, Fish)
        self.update_time_stamps()


    def remove_worm(self, obj):
        ''' Remove a worm from the aquarium. '''
        self.worm_objs =  self._remove_object(self.worm_objs, obj, Worm)


    def electric_potential_and_field_single_fish(self, points, fish_id, return_potential=True, return_field=True, include_image_point_currents=True):
        ''' Returns electric potential/field computed at given points due to a single fish. Implemented for "image" currents child classes - other types of aquariums or boundaries will need to implement their own.'''
        # get the point currents from the fish; magnitude and location
        N_time_steps = self.time_stamps.shape[0]
        fish = self.fish_objs[fish_id]
        pc_mag = fish.get_point_currents_magnitude()
        pc_loc = fish.get_point_currents_location()
        # get the image point currents, computed according to the boundary
        assert fish.is_equal(self.image_point_currents_magnitude[fish_id][0]), 'Currents and images should correspond to the same fish.'
        assert fish.is_equal(self.image_point_currents_location[ fish_id][0]), 'Currents and images should correspond to the same fish.'
        ipc_mag = np.empty(shape=0)     if not include_image_point_currents else self.image_point_currents_magnitude[fish_id][1]
        ipc_loc = np.empty(shape=(0,3)) if not include_image_point_currents else self.image_point_currents_location[ fish_id][1]
        # put together magnitudes and locations
        all_mag = np.hstack([pc_mag, ipc_mag])
        all_loc = np.vstack([pc_loc, ipc_loc])

        # process wave-form
        waveform = fish.get_eod_wave_form()
        if waveform.shape[0] < N_time_steps:
            waveform = np.hstack([waveform, np.zeros(N_time_steps-waveform.shape[0])])

        # compute the relative points into shape N_points x N_currents x 3 
        relative_points = points[:,np.newaxis] - all_loc  # N_points x N_currents x 3 
        norm_relative_points = np.linalg.norm(relative_points, axis=2)                       # N_points x N_currents
        individual_potential = all_mag / (4 * self.sig * np.pi * norm_relative_points)       # N_points x N_currents
        potential = None if not return_potential else individual_potential.sum(1)[:,np.newaxis]  # N_points x 1
        field     = None if not return_field     else ((individual_potential / np.power(norm_relative_points,2))[:,:,np.newaxis] * relative_points).sum(1)[:,:,np.newaxis]  # N_points x 3 x 1
        return potential, field, waveform


    def electric_potential_and_field(self, points, return_potential=True, return_field=True):
        ''' Returns electric potential/field computed at given points. Implemented for "image" currents child classes - other types of aquariums or boundaries will nee to implement their own.'''
        assert len(self.fish_objs) > 0, 'There must be at least one fish in the aquarium to compute electric potential/field.'
        _, points    = self.verify_points(points, simple_return=False)

        N_time_steps = self.time_stamps.shape[0]
        potential = None
        field     = None
        if return_potential:
            potential = np.zeros([points.shape[0], N_time_steps])
        if return_field:
            field     = np.zeros([points.shape[0], points.shape[1], N_time_steps])

        # for every fish, get its currents and locations and add to potential and field
        # do the same for each image charge and its corresponding location
        for i in range(len(self.fish_objs)):
            temp_potential, temp_field, waveform = self.electric_potential_and_field_single_fish(points, i, return_potential, return_field)
            if return_potential:
                potential += temp_potential * waveform
            if return_field:
                field     += temp_field * waveform
        if return_potential:
            assert (potential.shape == np.array([points.shape[0], N_time_steps])).all(), 'Returned electric potential should be shape (N x T)'
        if return_field:
            assert (field.shape   == np.array([points.shape[0],3, N_time_steps])).all(), 'Returned electric field should be shape (N x 3 x T)'
        return potential, field


    def transdermal_signal_for_all_fish(self, include_perturbations=True):
        ''' Compute the electric images for all fish in the quarium. '''
        # gather all receptors from all fish
        points = np.array([]).reshape(0,3)
        for fish in self.fish_objs:
            points = np.vstack([points, fish.points])

        # compute the electric field from all active current generating objects in the aquarium, i.e. all fish
        _, E_field = self.electric_potential_and_field(points, return_potential=False)
        assert (E_field.shape   == np.array([points.shape[0],3, self.time_stamps.shape[0]])).all(), 'Electric field should be shape (N x 3 x T)'

        # compute the electric field from all passive objects in the aquarium, i.e. all worms
        if include_perturbations:
            for worm in self.worm_objs:
                _, E_field_from_worm = worm.perturbation_trace(points, self, return_potential=False, return_field=True)
                E_field += E_field_from_worm

        # compute the electric image for each fish
        electric_images = np.zeros([E_field.shape[0], E_field.shape[2]])
        start_id = 0
        for fish in self.fish_objs:
            end_id = start_id + fish.get_N_points()
            electric_image_current_fish = fish.compute_transdermal_signal(E_field[start_id:end_id], self.sig)
            assert (electric_image_current_fish.shape == np.array([end_id-start_id, self.time_stamps.shape[0]])).all(), 'Electric image for current fish should be shape (N_points x T). '
            electric_images[start_id:end_id] = electric_image_current_fish
            start_id = end_id
        return points, electric_images


    def select_bounded_points(self, points, simple_return):
        ''' Select only the given points which are within the aquarium's boundaries. '''
        within_boundaries_ids = (np.zeros(points.shape[0]) == np.zeros(points.shape[0]))
        for boundary in self.boundaries:
            thruth_val_current, points = boundary.verify_points(points, simple_return=False)
            within_boundaries_ids &= thruth_val_current
        if simple_return: 
            return points[within_boundaries_ids] 
        else: 
            return points[within_boundaries_ids], within_boundaries_ids


    def verify_points(self, points, obj=None, simple_return=True):
        ''' Check that all given points are within aquarium boundary. '''
        thruth_val = True
        failed_boundaries = []
        for boundary in self.boundaries:
            thruth_val_current, points = boundary.verify_points(points, simple_return=False)
            if not thruth_val_current.all():
                failed_boundaries.append(boundary)
                thruth_val = False
        assert thruth_val, f'Some points lie outside boundaries {failed_boundaries}.' + ('' if obj is None else f'These points belong to object {obj}, with details:\n{obj.details()}')  
        if simple_return:
            return True 
        else:
            return True, points


    def update_time_stamps(self):
        ''' Update the time stamps of the Aquarium. Time 0 is the start of a simulation (start of the EOD trace of the first fish to emit an EOD). '''
        self.time_stamps = np.array([])
        for fish in self.fish_objs:
            fish_time_stamps = fish.get_time_stamps()
            if fish_time_stamps.shape[0] > self.time_stamps.shape[0]:
                self.time_stamps = fish_time_stamps


    # "time_points": can be an integer (distributes times uniformly in self.time_stamps) 
    #                or list of integers which index into self.time_stamps to select frame_times
    #                or tuple of (list, prefix) which provides time stamps to select frame_times
    def visualize_aquarium(self, 
                           potential=None, E_field=None, electric_image=None,
                           time_points=10, shown_time_prefix='',
                           range_points=30, lengths_prefix='',
                           show_fish=False, show_electric_image=False, show_normals=False, show_point_currents=False, show_image_currents=False,
                           show_worms=False, 
                           show_boundaries=False, 
                           show_potential=False, show_field=False, potential_double_sided_percentile=10, E_field_double_sided_percentile=10,
                           include_active_objects=False, include_passive_objects=False,
                           electric_image_perturbation_only=False,
                           xaxis_title='X AXIS TITLE', yaxis_title='Y AXIS TITLE', zaxis_title='Z AXIS TITLE',
                           ):
        start_time = time.time()
        ########################################################################
        # find aquarium (x,y,z) ranges based on the objects inside
        points = np.array([]).reshape(0,3)
        for fish in self.fish_objs:
            points = np.vstack([points, fish.get_points()])
        for worm in self.worm_objs:
            points = np.vstack([points, worm.get_points()])
        min_ranges = points.min(0)
        max_ranges = points.max(0)
        del_ranges = max_ranges - min_ranges
        min_ranges = np.array([-15, -10, -10])/100  # min_ranges - del_ranges/2
        max_ranges = np.array([5,    10,  10])/100  # max_ranges + del_ranges/2

        ########################################################################
        # determine the frame times for the animation
        frame_times = []
        if type(time_points) == type(0):
            frame_times = [int(x) for x in np.linspace(self.time_stamps.shape[0]/3,2*self.time_stamps.shape[0]/3,time_points)]
        elif type(time_points) == type([]):
            for tp in time_points:
                assert type(tp) == type(0) or type(tp) == type(np.int64(0)), '"time_points" should be a list of ints, which index into self.time_stamps to select frame_times.'
                assert tp >= 0, '"time_points" should not contain negative elements.'
                assert tp < self.time_stamps.shape[0], '"time_points" should be bounded from above by number of time stamps.'
            time_points.sort()
            frame_times = time_points
        elif type(time_points) == type(()):
            time_points = convert2mainSI(time_points)
            time_points.sort()
            frame_times = list((time_points[:,np.newaxis] > self.time_stamps).argmin(1))
        else:
            raise ValueError('"time_points" should be of correct type: int, list of ints or tuple of list and prefix.')
        prefixed_time_stamps = add_prefix(self.time_stamps, shown_time_prefix)

        ########################################################################
        # potential or field generation
        if show_potential or show_field:
            # build the mesh-grids for plotting
            X, Y, Z = np.mgrid[min_ranges[0]:max_ranges[0]:range_points*1j,
                               min_ranges[1]:max_ranges[1]:range_points*1j,
                               min_ranges[2]:max_ranges[2]:range_points*1j]
            X = X.flatten()
            Y = Y.flatten()
            Z = Z.flatten()
            mesh_grid_points = np.vstack([X,Y,Z]).T

            mesh_grid_points, within_boundary_ids = self.select_bounded_points(mesh_grid_points, simple_return=False)
            print(within_boundary_ids.sum())
            X = X[within_boundary_ids]
            Y = Y[within_boundary_ids]
            Z = Z[within_boundary_ids]

            # compute potentials or fields
            if (potential is None) or (E_field is None):
                potential = 0
                E_field   = 0

                if include_active_objects:
                    pot, E_f = self.electric_potential_and_field(mesh_grid_points, show_potential, show_field)
                    if show_potential:
                        potential += pot
                    if show_field:
                        E_field   += E_f

                if include_passive_objects:
                    for worm in self.worm_objs:
                        pot, E_f = worm.compute_electric_potential_and_field_perturbations(mesh_grid_points, self, show_potential, show_field)
                        if show_potential:
                            potential += pot
                        if show_field:
                            E_field   += E_f

            if show_potential:
                assert (potential.shape == np.array([X.shape[0], self.time_stamps.shape[0]])).all(), 'Potential should be shape (N x T).'
                potential = potential[:,frame_times]
                # eliminate large potentials (in absolute value) for visualization
                potential_abs = np.abs(potential)
                max_potential_abs_in_time = potential_abs[:,potential_abs.max(0).argmax()]
                percentile_potential = np.percentile(max_potential_abs_in_time, 100-potential_double_sided_percentile)
                potential_abs[potential_abs > percentile_potential] = percentile_potential
                potential_final = potential_abs * np.sign(potential)
                # color scale for plotting
                potential_color_bound = np.max(np.abs([potential.min(), potential.max()]))

            if show_field:
                E_field_norm = np.sqrt(np.power(E_field,2).sum(1))
                max_over_time_id = E_field_norm.max(0).argmax()
                temp_E_field     = E_field_norm[:, max_over_time_id]
                bounded_E_field_locations = (temp_E_field < np.percentile(temp_E_field, 100-E_field_double_sided_percentile))
                X_E_f = X[bounded_E_field_locations]
                Y_E_f = Y[bounded_E_field_locations]
                Z_E_f = Z[bounded_E_field_locations]

                E_field = E_field[bounded_E_field_locations]
                assert (E_field.shape == np.array([X_E_f.shape[0], 3, self.time_stamps.shape[0]])).all(), 'E field should be shape (N x 3 x T).'
                E_field = E_field[:,:,frame_times]
                # color scale for plotting
                E_field_norm = np.sqrt(np.power(E_field,2).sum(1))
                E_field_color_bound = np.max(np.abs([E_field_norm.min(), E_field_norm.max()]))

        ########################################################################
        # electric image generation
        if show_fish and show_electric_image:
            if electric_image is None:
                if electric_image_perturbation_only:
                    _, base_image = self.transdermal_signal_for_all_fish(include_perturbations=False)
                    _, perturbed_image = self.transdermal_signal_for_all_fish(include_perturbations=True)
                    electric_image = perturbed_image - base_image
                else:
                    _, electric_image = self.transdermal_signal_for_all_fish(include_perturbations=True)
            assert electric_image.shape[1] == self.time_stamps.shape[0], 'Electric image should have time length T.'

            #$$$$$$$$$$$$$$$$$$$$
            temp = electric_image
            #$$$$$$$$$$$$$$$$$$$$

            electric_image = electric_image[:,frame_times]
        end_time = time.time()
        print('COMPUTING TIME: ', end_time - start_time, ' s.')

        ########################################################################
        ### generate frames for animation ######################################
        ########################################################################
        # initialize frames
        frames = []
        for i in range(len(frame_times)):
            # initialize data and name for current frame
            frame_data = []
            frame_name = '%r %ss' % (np.round(prefixed_time_stamps[frame_times[i]],3), shown_time_prefix)

            ########################################################################
            # show the potential 
            if show_potential:
                graph_obj = go.Volume(x=add_prefix(X, lengths_prefix), 
                                      y=add_prefix(Y, lengths_prefix), 
                                      z=add_prefix(Z, lengths_prefix), 
                                      value=potential[:,i],
                                      opacity=0.1, surface_count=40, showscale=False,
                                      colorscale='Picnic', showlegend=False,
                                      cmin=-potential_color_bound, cmax=potential_color_bound,
                                      caps= dict(x_show=False, y_show=False, z_show=False)
                                     )
                frame_data.append(graph_obj)

            ########################################################################
            # show the field
            if show_field:
                graph_obj = go.Cone(x=add_prefix(X_E_f, lengths_prefix),
                                    y=add_prefix(Y_E_f, lengths_prefix), 
                                    z=add_prefix(Z_E_f, lengths_prefix), 
                                    u=E_field[:,0,i], v=E_field[:,1,i], w=E_field[:,2,i],
                                    colorscale='Blues', sizemode="scaled", sizeref=0, 
                                    showlegend=False, opacity=0.8, showscale=False,
                                    cmin=-E_field_color_bound, cmax=E_field_color_bound)
                frame_data.append(graph_obj)

            ########################################################################
            # show each worm (including its size)
            if show_worms:
                for worm in self.worm_objs:
                    graph_obj = worm.create_graph_obj(size_scale=5000, units_prefix=lengths_prefix)
                    frame_data.append(graph_obj)

            ########################################################################
            # show each boundary
            if show_boundaries:
                raise NotImplementedError('Boundary visualization is not yet implemented.')

            ########################################################################
            # show each fish (including the electric image and normals)
            if show_fish or show_normals or show_point_currents or show_image_currents:
                # set up intensity range, if needed, outside the for-loop
                intensity_range = None
                if show_electric_image:
                    intensity_range = np.max(np.abs([electric_image.min(), electric_image.max()]))
                    intensity_range = [-intensity_range, intensity_range]
                # go through each fish
                start_id = 0
                for i_fi, fish in enumerate(self.fish_objs):
                    end_id = start_id + fish.get_N_points()

                    # show normals
                    if show_normals:
                        graph_obj = fish.create_normals_graph_obj(size_scale=show_normals, units_prefix=lengths_prefix)
                        frame_data.append(graph_obj)

                    # show fish point currents
                    if show_point_currents:
                        graph_obj = fish.create_point_currents_graph_obj(marker_size=show_point_currents, units_prefix=lengths_prefix)
                        frame_data.append(graph_obj)

                    # show IMAGE point currents
                    if show_image_currents:
                        graph_obj = self.create_image_currents_graph_obj(i_fi, marker_size=show_image_currents, units_prefix=lengths_prefix)
                        frame_data.append(graph_obj)

                    # show fish points; gather in intensity map shown on the fish surface
                    if show_fish:
                        intensity = None
                        if show_electric_image:
                            intensity = electric_image[start_id:end_id, i]
                        graph_obj = fish.create_scatter_graph_obj(intensity=intensity, 
                                                                  intensity_range=intensity_range,
                                                                  units_prefix=lengths_prefix,)
                        frame_data.append(graph_obj)

                    start_id = end_id

            frames.append(go.Frame(data=frame_data, name=frame_name))


        ########################################################################
        ### construct figure ###################################################
        ########################################################################        
        if len(frames) == 0:
            raise ValueError('Not enough time points to compute - "time_points" should be at least 1.')
        elif len(frames) == 1:
            fig = go.Figure()
        else:
            fig = go.Figure(frames=frames)

        for graph_obj in frames[0].data:
            fig.add_trace(graph_obj)

        if len(frames) > 1:
            def frame_args(duration):
                return {"frame": {"duration": duration},
                        "mode": "immediate", "fromcurrent": True,
                        "transition": {"duration": duration, "easing": "linear"},
                       }

            sliders = [{"pad": {"b": 10, "t": 60},
                        "len": 0.9, "x": 0.1, "y": 0,
                         "steps": [{"args": [[f.name], frame_args(0)],
                                    "label": f.name,
                                    "method": "animate",
                                    }
                                    for k, f in enumerate(fig.frames)
                                    ],
                        }]

            fig.update_layout(updatemenus = [{"buttons":  [{"args": [None, frame_args(10)],
                                                            "label": "&#9654;", # play symbol
                                                            "method": "animate",},
                                                           {"args": [[None], frame_args(0)],
                                                            "label": "&#9724;", # pause symbol
                                                            "method": "animate",},],
                                              "direction": "left",
                                              "pad": {"r": 10, "t": 70},
                                              "type": "buttons",
                                              "x": 0.1, "y": 0,
                                             }],
                              sliders=sliders)

        fig.update_layout(scene = dict(
                                        xaxis = dict(
                                                     backgroundcolor="rgb(220, 220, 240)",
                                                     gridcolor="white",
                                                     showbackground=True,
                                                     zerolinecolor="grey",
                                                     range=add_prefix(np.array([min_ranges[0], max_ranges[0]]), lengths_prefix),
                                                    ),
                                        yaxis = dict(
                                                     backgroundcolor="rgb(240, 220, 240)",
                                                     gridcolor="white",
                                                     showbackground=True,
                                                     zerolinecolor="grey",
                                                     range=add_prefix(np.array([min_ranges[1], max_ranges[1]]), lengths_prefix),
                                                    ),
                                        zaxis = dict(
                                                     backgroundcolor="rgb(240, 240, 220)",
                                                     gridcolor="white",
                                                     showbackground=True,
                                                     zerolinecolor="grey",
                                                     range=add_prefix(np.array([min_ranges[2], max_ranges[2]]), lengths_prefix),
                                                    ),
                                        xaxis_title=xaxis_title + ' (%sm)'%lengths_prefix,
                                        yaxis_title=yaxis_title + ' (%sm)'%lengths_prefix,
                                        zaxis_title=zaxis_title + ' (%sm)'%lengths_prefix,
                                        # aspectmode='data',
                                        aspectratio=dict(x=1, 
                                                         y=(max_ranges[1] - min_ranges[1])/(max_ranges[0] - min_ranges[0]), 
                                                         z=(max_ranges[2] - min_ranges[2])/(max_ranges[0] - min_ranges[0])),
                                      ),
                            width=None,
                            height=None,
                            margin=dict(r=0, l=0, b=0, t=0),
                          )

        fig.show()
        print('PLOTTING TIME: ', time.time() - end_time, ' s.')

        if show_fish and show_electric_image:    
            return temp
        return


    def create_image_currents_graph_obj(self, i_fi, marker_size=15, units_prefix=''):
        ''' Create a plotly graphical object to insert into a plot at a later time. This GO shows point currents within the fish. '''
        mags = self.image_point_currents_magnitude[i_fi][1]
        locs = self.image_point_currents_location[i_fi][1]
        graph_obj = go.Scatter3d(x=add_prefix(locs[:,0], units_prefix), 
                                 y=add_prefix(locs[:,1], units_prefix), 
                                 z=add_prefix(locs[:,2], units_prefix), 
                                 mode='markers', showlegend=False,
                                 marker=dict(size=marker_size,
                                             color=mags,
                                             colorscale='Armyrose',
                                             opacity=1,
                                            )
                                )
        return graph_obj


    def details(self):
        ''' Provides the details of the object. Can be adjusted in child classes to include more information. '''
        details_string  =  super().details()
        details_string += f'This aquarium has boundaries {self.boundaries}.\n'
        return details_string


    def get_boundaries(self):
        return self.boundaries


    def get_fish(self):
        return self.fish_objs


    def get_worms(self):
        return self.worm_objs


    def get_image_point_currents(self):
        return self.image_point_currents_magnitude, self.image_point_currents_location


    def get_time_stamps(self):
        return self.time_stamps


    @classmethod
    def _initialize_input_argument_names(cls):
        inp_args  = super()._initialize_input_argument_names()
        inp_args += ['fish_objs', 'worm_objs', 'boundaries']
        return inp_args


    def run_tests(self):
        ''' Sanity assertion checks to ensure code robustness. '''
        super().run_tests()

        with open(os.devnull, "w") as f, contextlib.redirect_stdout(f):
            fish1 = Fish(nose_position=[0,1,0], fish_length=0.5, eod_wave_form=np.zeros(100), skin_resistivity=1)
            fish2 = IceCreamConeFishGeneration(nose_position=[0,0,1], fish_length=0.5, eod_wave_form=np.ones( 100), skin_resistivity=1, receptors_init=dict(method='random', head=100, body=200))
            fish3 = Fish(nose_position=[1,0,0], fish_length=0.5, eod_wave_form=np.zeros(100), skin_resistivity=2)
            worm1 = Worm(center_position=[1,2,3])
            worm2 = Worm(center_position=[2,1,3])
            worm3 = Worm(center_position=[1,3,2])

        N_fish  = len(self.fish_objs)
        N_worms = len(self.worm_objs)
        assert N_fish == len(self.image_point_currents_magnitude), 'Number of fish and number of sets of image point currents should match.'
        assert N_fish == len(self.image_point_currents_location), 'Number of fish and number of sets of image point currents should match.'
        self.insert_fish(fish1, _check_points=False)
        assert len(self.fish_objs) == N_fish + 1, 'Inserting a fish should increment the list by 1.'
        assert len(self.fish_objs) == len(self.image_point_currents_magnitude), 'Number of fish and number of sets of image point currents should match.'
        assert len(self.fish_objs) == len(self.image_point_currents_location), 'Number of fish and number of sets of image point currents should match.'
        
        self.insert_fish(fish2, _check_points=False)
        assert len(self.fish_objs) == N_fish + 2, 'Inserting two fish should increment the list by 2.'
        assert len(self.fish_objs) == len(self.image_point_currents_magnitude), 'Number of fish and number of sets of image point currents should match.'
        assert len(self.fish_objs) == len(self.image_point_currents_location), 'Number of fish and number of sets of image point currents should match.'
        
        self.insert_fish(fish1, _check_points=False)
        assert len(self.fish_objs) == N_fish + 2, 'Inserting the same fish again should leave the list unchanged.'
        assert len(self.fish_objs) == len(self.image_point_currents_magnitude), 'Number of fish and number of sets of image point currents should match.'
        assert len(self.fish_objs) == len(self.image_point_currents_location), 'Number of fish and number of sets of image point currents should match.'
        
        self.insert_fish(fish3, _check_points=False)
        assert len(self.fish_objs) == N_fish + 3, 'Inserting three fish should increment the list by 3.'
        assert len(self.fish_objs) == len(self.image_point_currents_magnitude), 'Number of fish and number of sets of image point currents should match.'
        assert len(self.fish_objs) == len(self.image_point_currents_location), 'Number of fish and number of sets of image point currents should match.'
       
        self.remove_fish(fish2)
        assert len(self.fish_objs) == N_fish+2, 'Removing one of the three fish just added should decrement the list by 1.'
        assert len(self.fish_objs) == len(self.image_point_currents_magnitude), 'Number of fish and number of sets of image point currents should match.'
        assert len(self.fish_objs) == len(self.image_point_currents_location), 'Number of fish and number of sets of image point currents should match.'
        
        self.remove_fish(fish1)
        assert len(self.fish_objs) == N_fish+1, 'Removing one of the two remaining fish just added should decrement the list by 1.'
        assert len(self.fish_objs) == len(self.image_point_currents_magnitude), 'Number of fish and number of sets of image point currents should match.'
        assert len(self.fish_objs) == len(self.image_point_currents_location), 'Number of fish and number of sets of image point currents should match.'

        self.remove_fish(fish3)
        assert len(self.fish_objs) == N_fish, 'Removing the three fish just added should leave the original list unchanged.'
        assert len(self.fish_objs) == len(self.image_point_currents_magnitude), 'Number of fish and number of sets of image point currents should match.'
        assert len(self.fish_objs) == len(self.image_point_currents_location), 'Number of fish and number of sets of image point currents should match.'
        
        self.insert_worm(worm1, _check_points=False)
        assert len(self.worm_objs) == N_worms + 1, 'Inserting a worm should increment the list by 1.'
        self.insert_worm(worm2, _check_points=False)
        assert len(self.worm_objs) == N_worms + 2, 'Inserting two worms should increment the list by 2.'
        self.insert_worm(worm1, _check_points=False)
        assert len(self.worm_objs) == N_worms + 2, 'Inserting the same worm again should leave the list unchanged.'
        self.insert_worm(worm3, _check_points=False)
        assert len(self.worm_objs) == N_worms + 3, 'Inserting three worms should increment the list by 3.'
        self.remove_worm(worm2)
        self.remove_worm(worm1)
        self.remove_worm(worm3)
        assert len(self.worm_objs) == N_worms, 'Removing the three worms just added should leave the original list unchanged.'

        # back up aquarium
        temp_fish_objs   = self.fish_objs
        temp_worm_objs   = self.worm_objs
        temp_image_mag   = self.image_point_currents_magnitude
        temp_image_loc   = self.image_point_currents_location
        temp_time_stamps = self.time_stamps

        self.empty_aquarium()
        assert self.fish_objs == [], 'Emptying aquarium should leave fish list empty.'
        assert self.worm_objs == [], 'Emptying aquarium should leave worm list empty.'
        assert self.image_point_currents_magnitude == [], 'Emptying aquarium should leave no image currents.'
        assert self.image_point_currents_location == [], 'Emptying aquarium should leave no image currents.'

        # restore the aquarium to initial state
        self.fish_objs = temp_fish_objs
        self.worm_objs = temp_worm_objs
        self.image_point_currents_magnitude = temp_image_mag
        self.image_point_currents_location  = temp_image_loc
        self.time_stamps = temp_time_stamps
        return 'Success!'
